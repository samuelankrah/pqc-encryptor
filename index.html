<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>ENTAQ | Future-Proof Your Secrets</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { background:#fff; color:#222; font-family:'Segoe UI',sans-serif; max-width:800px; margin:auto; padding:2rem; line-height:1.5; }
    header{text-align:center;margin-bottom:2rem;}
    img.logo{width:140px;display:block;margin:auto;}
    h1{color:#0066cc;margin:.5rem 0;}
    .tagline{color:#555;margin-bottom:1.5rem;}
    .usecase{background:#e8f4fd;border-left:5px solid #0066cc;padding:1rem;border-radius:8px;margin-bottom:1.5rem;}
    .banner{background:#f9f9f9;border-left:5px solid #0066cc;padding:1rem;border-radius:8px;margin-bottom:1.5rem;}
    .toggle{color:#0066cc;cursor:pointer;text-align:center;margin:1rem 0;}
    .info{display:none;background:#fdfdfd;border:1px solid #ccc;border-radius:8px;padding:1rem;}
    label{display:block;margin-top:1rem;font-weight:bold;}
    textarea,button{width:100%;padding:1rem;margin-top:.5rem;border-radius:8px;font-size:1rem;border:1px solid #ccc;}
    textarea{resize:vertical;min-height:120px;}
    button{font-weight:bold;border:none;cursor:pointer;}
    .encrypt-btn{background:#0066cc;color:#fff;}
    .decrypt-btn{background:#ff6600;color:#fff;margin-top:.5rem;}
    .output{display:none;background:#fbfbfb;border:1px solid #ddd;border-radius:8px;padding:1rem;margin-top:1.5rem;word-break:break-word;}
    .output.visible{display:block;}
    .label{font-weight:bold;margin-top:1rem;}
    .small{font-size:.85rem;color:#666;}
    @media(max-width:600px){body{padding:1rem;}textarea,button{font-size:.9rem}}
  </style>
</head>
<body>

  <header>
    <img src="ENTAQ Logo!.png" alt="ENTAQ Logo" class="logo"/>
    <h1>ENTAQ</h1>
    <p class="tagline">Encrypted. Entangled. Empowered.</p>
  </header>

  <div class="usecase">
    üîê <strong>Use Case:</strong><br>
    Imagine sending a private note; your password, a family photo, or a love letter to someone you trust.  
    You want to be the only person (+ your friend) who can ever read it, even 50 years from now.
  </div>

  <div class="banner">
    üîê <strong>Post-Quantum Encryption in Action</strong><br>
    Demonstrating Kyber768 (quantum-safe) + AES-GCM, all in your browser.
  </div>

  <div id="toggleBtn" class="toggle">üîé Show ‚ÄúWhy This Matters‚Äù</div>
  <div id="infoBox" class="info" aria-live="polite">
    <p><strong>Why Post-Quantum?</strong> Today‚Äôs encryption (RSA/ECC) will eventually fall to quantum computers. Kyber768 is NIST-standardized to resist that future threat.</p>
    <p><strong>Hybrid Encryption Flow:</strong>
      <ol>
        <li>Generate a Kyber768 keypair (your digital padlock).</li>
        <li>Encapsulate ‚Üí derive a shared secret key.</li>
        <li>Encrypt your message with AES-GCM using that key (locks it). </li>
        <li>Decapsulate + decrypt to prove round-trip integrity (unlock it).</li>
      </ol>
    </p>
    <p class="small">Aligned with PCI DSS 4.0 &amp; NIST SP 800-57/208. Runs 100% in your browser‚Äîno server, no data leaves your machine.</p>
  </div>

  <label for="plaintext">Enter Your Secret Message</label>
  <textarea id="plaintext" placeholder="e.g., ‚ÄòMeet me at 6pm‚Äô"></textarea>
  <button id="encryptBtn" class="encrypt-btn" disabled>Loading PQC Engine‚Ä¶</button>
  <button id="decryptBtn" class="decrypt-btn" disabled>Decrypt</button>

  <div id="results" class="output" aria-live="polite">
    <h2>üîê Encrypted</h2>
    <div class="label">What an attacker sees:</div>
    <div id="ciphertext"></div>

    <h2>üîì Decrypted</h2>
    <div class="label">Your original message:</div>
    <div id="decrypted"></div>

    <p class="small">Only someone with the secret key (you!) can turn that gibberish back into your note.</p>
  </div>

  <script type="module">
    console.log("üöÄ Loading Kyber768 module...");
    import { MlKem768 } from "https://esm.sh/mlkem@2.3.1";
    console.log("‚úÖ Kyber768 ready:", MlKem768);

    const toggleBtn = document.getElementById("toggleBtn");
    const infoBox   = document.getElementById("infoBox");
    const encBtn    = document.getElementById("encryptBtn");
    const decBtn    = document.getElementById("decryptBtn");
    const results   = document.getElementById("results");
    const ctEl      = document.getElementById("ciphertext");
    const decEl     = document.getElementById("decrypted");
    const ptEl      = document.getElementById("plaintext");

    let sk, ctBytes, sharedSecret, iv, payload;

    // Enable Encrypt now module is loaded
    encBtn.disabled = false;
    encBtn.textContent = "Encrypt";

    // Toggle ‚ÄúWhy This Matters‚Äù
    toggleBtn.onclick = () => {
      const show = infoBox.style.display !== "block";
      infoBox.style.display = show ? "block" : "none";
      toggleBtn.textContent = show 
        ? "üîé Hide ‚ÄúWhy This Matters‚Äù" 
        : "üîé Show ‚ÄúWhy This Matters‚Äù";
    };

    // Encrypt
    encBtn.onclick = async () => {
      const msg = ptEl.value.trim();
      if (!msg) return alert("Please enter a message.");
      encBtn.disabled = true; encBtn.textContent = "Encrypting‚Ä¶";
      decBtn.disabled = true; results.classList.remove("visible");

      const kem = new MlKem768();
      const [pk, skLocal] = await kem.generateKeyPair();
      sk = skLocal;

      // Encapsulate using the public key
      [ctBytes, sharedSecret] = await kem.encap(pk);

      // AES-GCM encrypt
      iv = crypto.getRandomValues(new Uint8Array(12));
      const aesKey = await crypto.subtle.importKey("raw", sharedSecret, "AES-GCM", false, ["encrypt"]);
      const ctBuf = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, new TextEncoder().encode(msg));
      payload = new Uint8Array(iv.length + ctBuf.byteLength);
      payload.set(iv, 0);
      payload.set(new Uint8Array(ctBuf), iv.length);

      // Display encrypted text
      ctEl.textContent = btoa(String.fromCharCode(...payload));
      decEl.textContent = "(Click Decrypt to reveal!)";
      results.classList.add("visible");

      encBtn.disabled = false; encBtn.textContent = "Encrypt";
      decBtn.disabled = false;
    };

    // Decrypt
    decBtn.onclick = async () => {
      decBtn.disabled = true; decBtn.textContent = "Decrypting‚Ä¶";
      try {
        const kem = new MlKem768();
        const ss2 = await kem.decap(ctBytes, sk);
        const aesKey = await crypto.subtle.importKey("raw", ss2, "AES-GCM", false, ["decrypt"]);
        const ptBuf = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, payload.slice(iv.length));
        decEl.textContent = new TextDecoder().decode(ptBuf);
      } catch {
        decEl.textContent = "‚ö†Ô∏è Decryption failed";
      }
      decBtn.disabled = false; decBtn.textContent = "Decrypt";
    };
  </script>
  <!-- 1) Minimal UI -->
<section id="demo-cert" style="margin-top:24px;padding:16px;border:1px solid #e5e7eb;border-radius:12px">
  <h3>Generate Demo Certificate (PEM)</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0">
    <input id="certCN" placeholder="Common Name (e.g., entaq.local)" />
    <input id="certSAN" placeholder="SAN DNS (optional)" />
    <select id="certAlg">
      <option value="ECDSA">ECDSA P-256 (SHA-256)</option>
      <option value="RSA">RSA 2048 (SHA-256)</option>
    </select>
    <button id="btnGenCert">Generate</button>
  </div>
  <div>
    <textarea id="pemCert" readonly style="width:100%;min-height:140px" placeholder="PEM certificate will appear here"></textarea>
  </div>
  <div style="display:flex;gap:8px;margin-top:8px">
    <button id="dlCert">Download Cert (.pem)</button>
    <button id="copyCert">Copy PEM</button>
    <small style="opacity:.7">Public certificate only. Keep private keys secret.</small>
  </div>
</section>

<!-- 2) Library for X.509 (browser-only, MIT) -->
<script src="https://cdn.jsdelivr.net/npm/jsrsasign@10.9.0/lib/jsrsasign-all-min.js"></script>

<!-- 3) Generator script -->
<script>
(async function () {
  const $ = (id)=>document.getElementById(id);
  const b64 = (arr)=>window.btoa(String.fromCharCode(...new Uint8Array(arr)));
  function toPem(label, derHex){
    const b = window.hex2b64(derHex);
    return `-----BEGIN ${label}-----\n` + b.replace(/(.{64})/g,"$1\n") + `\n-----END ${label}-----\n`;
  }
  async function genECDSA() {
    // WebCrypto keypair (P-256)
    const kp = await crypto.subtle.generateKey({ name:"ECDSA", namedCurve:"P-256" }, true, ["sign","verify"]);
    const spki = await crypto.subtle.exportKey("spki", kp.publicKey);
    const pkcs8 = await crypto.subtle.exportKey("pkcs8", kp.privateKey);

    // Build self-signed X.509 with jsrsasign using the SPKI
    const pub = KJUR.asn1.ASN1Util.newObject({ 'seq': KJUR.asn1.ASN1Util.newObject({}) }); // placeholder (we‚Äôll set via KEYUTIL)
    const prv = KEYUTIL.getKey({ kty: "EC", crv: "P-256", d: null }); // placeholder

    // Import raw keys into jsrsasign
    const jsPub = KEYUTIL.getKey(await KEYUTIL.parsePublicRawSPKI(spki));
    const jsPrv = KEYUTIL.getKey(await KEYUTIL.parsePrivateRawPKCS8(pkcs8));

    const cn  = $("certCN").value.trim() || "ENTAQ Demo";
    const san = $("certSAN").value.trim();
    const cert = new KJUR.asn1.x509.Certificate({
      version: 3,
      serial: KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHexString(new KJUR.BigInteger(String(Date.now()))),
      sigalg: "SHA256withECDSA",
      issuer: { str: `/CN=${cn}` },
      subject: { str: `/CN=${cn}` },
      notbefore: KJUR.jws.IntDate.intDate2Zulu(KJUR.jws.IntDate.getNow()),
      notafter:  KJUR.jws.IntDate.intDate2Zulu(KJUR.jws.IntDate.getNow() + 365*24*3600),
      sbjpubkey: jsPub,
      ext: [
        new KJUR.asn1.x509.BasicConstraints({ cA:false }),
        new KJUR.asn1.x509.KeyUsage({ bin: "00000110" }), // digitalSignature,keyEncipherment-ish
      ]
    });
    if (san) cert.appendExtension(new KJUR.asn1.x509.SubjectAltName({ array:[{ dns: san }] }));

    cert.sign(jsPrv, "SHA256withECDSA");
    const derHex = cert.getEncodedHex();
    return { pemCert: toPem("CERTIFICATE", derHex) };
  }

  async function genRSA() {
    const kp = await crypto.subtle.generateKey(
      { name:"RSASSA-PKCS1-v1_5", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
      true, ["sign","verify"]
    );
    const spki = await crypto.subtle.exportKey("spki", kp.publicKey);
    const pkcs8 = await crypto.subtle.exportKey("pkcs8", kp.privateKey);

    const jsPub = KEYUTIL.getKey(await KEYUTIL.parsePublicRawSPKI(spki));
    const jsPrv = KEYUTIL.getKey(await KEYUTIL.parsePrivateRawPKCS8(pkcs8));

    const cn  = $("certCN").value.trim() || "ENTAQ Demo";
    const san = $("certSAN").value.trim();
    const cert = new KJUR.asn1.x509.Certificate({
      version: 3,
      serial: KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHexString(new KJUR.BigInteger(String(Date.now()))),
      sigalg: "SHA256withRSA",
      issuer: { str: `/CN=${cn}` },
      subject:{ str: `/CN=${cn}` },
      notbefore: KJUR.jws.IntDate.intDate2Zulu(KJUR.jws.IntDate.getNow()),
      notafter:  KJUR.jws.IntDate.intDate2Zulu(KJUR.jws.IntDate.getNow() + 365*24*3600),
      sbjpubkey: jsPub,
      ext: [
        new KJUR.asn1.x509.BasicConstraints({ cA:false }),
        new KJUR.asn1.x509.KeyUsage({ bin: "00000110" })
      ]
    });
    if (san) cert.appendExtension(new KJUR.asn1.x509.SubjectAltName({ array:[{ dns: san }] }));

    cert.sign(jsPrv, "SHA256withRSA");
    const derHex = cert.getEncodedHex();
    return { pemCert: toPem("CERTIFICATE", derHex) };
  }

  $("btnGenCert").addEventListener("click", async ()=>{
    $("pemCert").value = "Generating‚Ä¶";
    try{
      const alg = $("certAlg").value;
      const { pemCert } = (alg === "RSA") ? await genRSA() : await genECDSA();
      $("pemCert").value = pemCert;
    }catch(e){
      $("pemCert").value = "Error: " + e.message;
    }
  });

  function download(filename, text){
    const blob = new Blob([text], {type: "application/x-pem-file"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href=url; a.download=filename; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
  }
  $("dlCert").addEventListener("click", ()=> download("entaq-demo-cert.pem", $("pemCert").value));
  $("copyCert").addEventListener("click", async ()=>{
    await navigator.clipboard.writeText($("pemCert").value);
    $("copyCert").textContent = "Copied!";
    setTimeout(()=>{$("copyCert").textContent="Copy PEM";}, 1200);
  });
})();
</script>
</body>
</html>

